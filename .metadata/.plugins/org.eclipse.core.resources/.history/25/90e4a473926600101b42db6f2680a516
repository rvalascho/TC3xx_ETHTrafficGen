/**********************************************************************************************************************
 * \file ETH_LowLevel.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#define TOGGLE 1                                                /* Select  1 for DP83825i and 0 for RTL8211F        */

#include "IfxGeth.h"
#include "IfxGeth_Eth.h"

#if TOGGLE==1
#include "IfxGeth_Phy_Dp83825i.h"
#endif

#if TOGGLE==0
#include "IfxGeth_Phy_Rtl8211f.h"
#endif
#include "ETH_LowLevel.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/



#define CPU_WHICH_SERVICE_ETHERNET 0

#define ISR_PRIORITY_OS_TICK        99                          /* Define the timer interrupt priority              */
#define ISR_PRIORITY_GETH_TX        100                         /* Define the Ethernet transmit interrupt priority  */
#define ISR_PRIORITY_GETH_RX        101                         /* Define the Ethernet receive interrupt priority   */

#if TOGGLE==0
/* Pins for RTL8211F RMII connection */
#define ETH_GREFCLK_PIN             IfxGeth_GREFCLK_P11_5_IN
#define ETH_RXCTL_PIN               IfxGeth_RXCTLA_P11_11_IN
#define ETH_RXCLK_PIN               IfxGeth_RXCLKA_P11_12_IN
#define ETH_RXD0_PIN                IfxGeth_RXD0A_P11_10_IN
#define ETH_RXD1_PIN                IfxGeth_RXD1A_P11_9_IN
#define ETH_RXD2_PIN                IfxGeth_RXD2A_P11_8_IN
#define ETH_RXD3_PIN                IfxGeth_RXD3A_P11_7_IN
#define ETH_MDC_PIN                 IfxGeth_MDC_P21_2_OUT
#define ETH_MDIO_PIN                IfxGeth_MDIO_P21_3_INOUT
#define ETH_TXD0_PIN                IfxGeth_TXD0_P11_3_OUT
#define ETH_TXD1_PIN                IfxGeth_TXD1_P11_2_OUT
#define ETH_TXD2_PIN                IfxGeth_TXD2_P11_1_OUT
#define ETH_TXD3_PIN                IfxGeth_TXD3_P11_0_OUT
#define ETH_TXCTL_PIN               IfxGeth_TXCTL_P11_6_OUT
#define ETH_TXCLK_PIN               IfxGeth_TXCLK_P11_4_OUT
#endif

#if TOGGLE==1
/* Pins for DP83825U RMII connection */
#define ETH_CRSDIV_PIN              IfxGeth_CRSDVA_P11_11_IN
#define ETH_REFCLK_PIN              IfxGeth_REFCLKA_P11_12_IN
#define ETH_TXEN_PIN                IfxGeth_TXEN_P11_6_OUT
#define ETH_RXD0_PIN                IfxGeth_RXD0A_P11_10_IN
#define ETH_RXD1_PIN                IfxGeth_RXD1A_P11_9_IN
#define ETH_MDC_PIN                 IfxGeth_MDC_P21_2_OUT
#define ETH_MDIO_PIN                IfxGeth_MDIO_P21_3_INOUT
#define ETH_TXD0_PIN                IfxGeth_TXD0_P11_3_OUT
#define ETH_TXD1_PIN                IfxGeth_TXD1_P11_2_OUT
#endif
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGeth_Eth ethernetif;

uint32 isrTxCount=0;
uint32 isrRxCount=0;
uint8 channel0TxBuffer1[IFXGETH_MAX_TX_DESCRIPTORS][IFXGETH_MAX_TX_BUFFER_SIZE];
uint8 channel0RxBuffer1[IFXGETH_MAX_RX_DESCRIPTORS][IFXGETH_MAX_RX_BUFFER_SIZE];
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/* pin configuration RTL8211F */
#if TOGGLE == 0
const IfxGeth_Eth_RgmiiPins rgmii_pins = {
                                   .txClk = &ETH_TXCLK_PIN,     /* TXCLK */
                                   .txd0 = &ETH_TXD0_PIN,       /* TXD0 */
                                   .txd1 = &ETH_TXD1_PIN,       /* TXD1 */
                                   .txd2 = &ETH_TXD2_PIN,       /* TXD2 */
                                   .txd3 = &ETH_TXD3_PIN,       /* TXD3 */
                                   .txCtl = &ETH_TXCTL_PIN,     /* TXCTL */
                                   .rxClk = &ETH_RXCLK_PIN,     /* RXCLK */
                                   .rxd0 = &ETH_RXD0_PIN,       /* RXD0 */
                                   .rxd1 = &ETH_RXD1_PIN,       /* RXD1 */
                                   .rxd2 = &ETH_RXD2_PIN,       /* RXD2 */
                                   .rxd3 = &ETH_RXD3_PIN,       /* RXD3 */
                                   .rxCtl = &ETH_RXCTL_PIN,     /* RXCTL */
                                   .mdc = &ETH_MDC_PIN,         /* MDC */
                                   .mdio = &ETH_MDIO_PIN,       /* MDIO */
                                   .grefClk = &ETH_GREFCLK_PIN  /* GREFCLK */
};
#endif

#if TOGGLE==1
/* pin configuration DP83825I*/
const IfxGeth_Eth_RmiiPins rmii_pins = {
                                   .crsDiv = &ETH_CRSDIV_PIN,   /* CRSDIV */
                                   .refClk = &ETH_REFCLK_PIN,   /* REFCLK */
                                   .rxd0 = &ETH_RXD0_PIN,       /* RXD0 */
                                   .rxd1 = &ETH_RXD1_PIN,       /* RXD1 */
                                   .mdc = &ETH_MDC_PIN,         /* MDC */
                                   .mdio = &ETH_MDIO_PIN,       /* MDIO */
                                   .txd0 = &ETH_TXD0_PIN,       /* TXD0 */
                                   .txd1 = &ETH_TXD1_PIN,       /* TXD1 */
                                   .txEn = &ETH_TXEN_PIN        /* TXEN */
};
#endif

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
#if TOGGLE==1
void ETH_lowlevel_init_RMII()
{
    // Enable GETH module early
    IfxGeth_enableModule(&MODULE_GETH);

    // Configure MDC pin and MDIO routing
    IfxPort_setPinModeOutput(ETH_MDC_PIN.pin.port, ETH_MDC_PIN.pin.pinIndex, IfxPort_OutputMode_pushPull, ETH_MDC_PIN.select);
    GETH_GPCTL.B.ALTI0  = ETH_MDIO_PIN.inSelect;

    // Manually reset PHY before MAC init
    GETH_MAC_MDIO_DATA.U = 0x8000;  // Reset bit
    GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) | (0x00 << 2) | (1 << 0);  // Write to BMCR
    while (GETH_MAC_MDIO_ADDRESS.B.GB);  // Wait for MDIO ready

    // Poll until reset is complete
    do {
        GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) | (0x00 << 2) | (1 << 0);  // Read BMCR
        while (GETH_MAC_MDIO_ADDRESS.B.GB);
    } while (GETH_MAC_MDIO_DATA.U & 0x8000);

    // Prepare GETH config
    IfxGeth_Eth_Config GethConfig;
    IfxGeth_Eth_initModuleConfig(&GethConfig, &MODULE_GETH);

    GethConfig.phyInterfaceMode = IfxGeth_PhyInterfaceMode_rmii;
    GethConfig.pins.rmiiPins = &rmii_pins;
    GethConfig.mac.lineSpeed = IfxGeth_LineSpeed_100Mbps;
    GethConfig.mac.loopbackMode = IfxGeth_LoopbackMode_disable;
    GethConfig.mac.macAddress[0] = 0x66;
    GethConfig.mac.macAddress[1] = 0x55;
    GethConfig.mac.macAddress[2] = 0x44;
    GethConfig.mac.macAddress[3] = 0x33;
    GethConfig.mac.macAddress[4] = 0x22;
    GethConfig.mac.macAddress[5] = 0x11;

    GethConfig.mtl.numOfTxQueues = 1;
    GethConfig.mtl.numOfRxQueues = 1;
    GethConfig.mtl.txQueue[0].txQueueSize = IfxGeth_QueueSize_2560Bytes;
    GethConfig.mtl.txQueue[0].storeAndForward = TRUE;
    GethConfig.mtl.rxQueue[0].rxQueueSize = IfxGeth_QueueSize_2560Bytes;
    GethConfig.mtl.rxQueue[0].rxDmaChannelMap = IfxGeth_RxDmaChannel_0;
    GethConfig.mtl.rxQueue[0].storeAndForward = TRUE;

    GethConfig.dma.numOfTxChannels = 1;
    GethConfig.dma.numOfRxChannels = 1;
    GethConfig.dma.txChannel[0].channelId = IfxGeth_TxDmaChannel_0;
    GethConfig.dma.txChannel[0].txDescrList = (IfxGeth_TxDescrList*)&IfxGeth_Eth_txDescrList[0];
    GethConfig.dma.txChannel[0].txBuffer1StartAddress = (uint32 *)&channel0TxBuffer1[0][0];
    GethConfig.dma.txChannel[0].txBuffer1Size = IFXGETH_MAX_TX_BUFFER_SIZE;

    GethConfig.dma.rxChannel[0].channelId = IfxGeth_RxDmaChannel_0;
    GethConfig.dma.rxChannel[0].rxDescrList = (IfxGeth_RxDescrList *)&IfxGeth_Eth_rxDescrList[0];
    GethConfig.dma.rxChannel[0].rxBuffer1StartAddress = (uint32 *)&channel0RxBuffer1[0][0];
    GethConfig.dma.rxChannel[0].rxBuffer1Size = IFXGETH_MAX_RX_BUFFER_SIZE;

    IfxSrc_Tos gethIsrProvider = CPU_WHICH_SERVICE_ETHERNET ?
        (IfxSrc_Tos)(CPU_WHICH_SERVICE_ETHERNET + 1) :
        (IfxSrc_Tos)CPU_WHICH_SERVICE_ETHERNET;

    GethConfig.dma.txInterrupt[0].channelId = IfxGeth_DmaChannel_0;
    GethConfig.dma.txInterrupt[0].priority = ISR_PRIORITY_GETH_TX;
    GethConfig.dma.txInterrupt[0].provider = gethIsrProvider;
    GethConfig.dma.rxInterrupt[0].channelId = IfxGeth_DmaChannel_0;
    GethConfig.dma.rxInterrupt[0].priority = ISR_PRIORITY_GETH_RX;
    GethConfig.dma.rxInterrupt[0].provider = gethIsrProvider;

    // Finalize MAC configuration
    IfxGeth_Eth_initModule(&ethernetif, &GethConfig);
    IfxGeth_Eth_Phy_Dp83825i_init();
    IfxGeth_Eth_startTransmitters(&ethernetif, 1);
    IfxGeth_Eth_startReceivers(&ethernetif, 1);

    // Check link and apply duplex/speed
    if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSTS == 1)
    {
        if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKMOD == 1)
            IfxGeth_mac_setDuplexMode(ethernetif.gethSFR, IfxGeth_DuplexMode_fullDuplex);
        else
            IfxGeth_mac_setDuplexMode(ethernetif.gethSFR, IfxGeth_DuplexMode_halfDuplex);

        switch (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSPEED)
        {
            case 0:
                IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_10Mbps);
                break;
            case 1:
                IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_100Mbps);
                break;
            default:
                IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_1000Mbps);
                break;
        }
    }
}
#endif

#if TOGGLE==0
void ETH_lowlevel_init_RGMII()
{

    //int     i;

    /* set MAC hardware address length */
    //netif->hwaddr_len = ETHARP_HWADDR_LEN;

    /* set MAC hardware address */
    //for (i = 0; i < ETHARP_HWADDR_LEN; i++)
    //{
    //    netif->hwaddr[i] = g_Lwip.eth_addr.addr[i];
    //}

    /* maximum transfer unit */
    //netif->mtu = 1500;

    /* device capabilities */
    /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
    /* we don't set the LINK_UP flag because we don't say when it is linked */
    //netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;

    /* Do whatever else is needed to initialize interface. */
    {
        IfxGeth_Eth_Config GethConfig;

        IfxGeth_Eth_initModuleConfig(&GethConfig, &MODULE_GETH);
        // this is our RTL8211F
        GethConfig.phyInterfaceMode = IfxGeth_PhyInterfaceMode_rgmii;
        GethConfig.pins.rgmiiPins = &rtl8211f_pins;
        GethConfig.mac.lineSpeed = IfxGeth_LineSpeed_100Mbps; //IfxGeth_LineSpeed_1000Mbps;
        // MAC core configuration
        GethConfig.mac.loopbackMode = IfxGeth_LoopbackMode_disable;
        GethConfig.mac.macAddress[0] = 0xDE;
        GethConfig.mac.macAddress[1] = 0xAD;
        GethConfig.mac.macAddress[2] = 0xBE;
        GethConfig.mac.macAddress[3] = 0xEF;
        GethConfig.mac.macAddress[4] = 0xDE;
        GethConfig.mac.macAddress[5] = 0xAD;

        // MTL configuration
        GethConfig.mtl.numOfTxQueues = 1;
        GethConfig.mtl.numOfRxQueues = 1;
        GethConfig.mtl.txQueue[0].txQueueSize = IfxGeth_QueueSize_2560Bytes;
        GethConfig.mtl.txQueue[0].storeAndForward = TRUE;
        GethConfig.mtl.rxQueue[0].rxQueueSize = IfxGeth_QueueSize_2560Bytes;
        GethConfig.mtl.rxQueue[0].rxDmaChannelMap = IfxGeth_RxDmaChannel_0;
        GethConfig.mtl.rxQueue[0].storeAndForward = TRUE;

        GethConfig.dma.numOfTxChannels = 1;
        GethConfig.dma.numOfRxChannels = 1;
        GethConfig.dma.txChannel[0].channelId = IfxGeth_TxDmaChannel_0;
        GethConfig.dma.txChannel[0].txDescrList = (IfxGeth_TxDescrList*)&IfxGeth_Eth_txDescrList[0];
        GethConfig.dma.txChannel[0].txBuffer1StartAddress = (uint32 *)&channel0TxBuffer1[0][0]; // user buffer
        GethConfig.dma.txChannel[0].txBuffer1Size = IFXGETH_MAX_TX_BUFFER_SIZE; // used to calculate the next descriptor  buffer offset

        GethConfig.dma.rxChannel[0].channelId = IfxGeth_RxDmaChannel_0;
        GethConfig.dma.rxChannel[0].rxDescrList = (IfxGeth_RxDescrList *)&IfxGeth_Eth_rxDescrList[0];
        GethConfig.dma.rxChannel[0].rxBuffer1StartAddress = (uint32 *)&channel0RxBuffer1[0][0]; // user buffer
        GethConfig.dma.rxChannel[0].rxBuffer1Size = IFXGETH_MAX_RX_BUFFER_SIZE; // user defined variable

        IfxSrc_Tos gethIsrProvider;

        if (CPU_WHICH_SERVICE_ETHERNET) gethIsrProvider = (IfxSrc_Tos)(CPU_WHICH_SERVICE_ETHERNET+1);
        else  gethIsrProvider = (IfxSrc_Tos)CPU_WHICH_SERVICE_ETHERNET;

        GethConfig.dma.txInterrupt[0].channelId = IfxGeth_DmaChannel_0;
        GethConfig.dma.txInterrupt[0].priority = ISR_PRIORITY_GETH_TX;  // priority
        GethConfig.dma.txInterrupt[0].provider = gethIsrProvider;
        GethConfig.dma.rxInterrupt[0].channelId = IfxGeth_DmaChannel_0;
        GethConfig.dma.rxInterrupt[0].priority = ISR_PRIORITY_GETH_RX;  // priority
        GethConfig.dma.rxInterrupt[0].provider = gethIsrProvider;


        /* first we reset our phy manually, to make sure that the phy is ready when we init our module */
        {
            IfxGeth_enableModule(&MODULE_GETH);
            IfxPort_setPinModeOutput(ETH_MDC_PIN.pin.port, ETH_MDC_PIN.pin.pinIndex, IfxPort_OutputMode_pushPull, ETH_MDC_PIN.select);
            GETH_GPCTL.B.ALTI0  = ETH_MDIO_PIN.inSelect;

            while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
            // first we wait that we are able to communicate with the Phy
            do
            {
                GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) | (3 << 2) | (1 << 0);
                while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
            } while (GETH_MAC_MDIO_DATA.U & 0x8000);                                                      // wait for reset to finish
            // reset PHY
            // put data
            GETH_MAC_MDIO_DATA.U = 0x8000;
            GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) |  (1 << 2) | (1 << 0);
            while (GETH_MAC_MDIO_ADDRESS.B.GB) {};

            do
            {
                GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) | (3 << 2) | (1 << 0);
                while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
            } while (GETH_MAC_MDIO_DATA.U & 0x8000);                                                      // wait for reset to finish
        }

        // initialize the module
        IfxGeth_Eth_initModule(&ethernetif, &GethConfig);

        IfxGeth_Eth_Phy_Rtl8211f_init();

        // and enable transmitter/receiver
        IfxGeth_Eth_startTransmitters(&ethernetif, 1);
        IfxGeth_Eth_startReceivers(&ethernetif, 1);

        // The ETH is ready for use now!
        /* we set the LINK_UP flag if we have a valid link */
        if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSTS == 1)
        {
            // we have a valid link
            //netif->flags |= NETIF_FLAG_LINK_UP;
            // we set the correct duplexMode
            if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKMOD == 1)
                IfxGeth_mac_setDuplexMode(ethernetif.gethSFR, IfxGeth_DuplexMode_fullDuplex);
            else
                IfxGeth_mac_setDuplexMode(ethernetif.gethSFR, IfxGeth_DuplexMode_halfDuplex);
            // we set the correct speed
            if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSPEED == 0)
                // 10MBit speed
                IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_10Mbps);
            else
                if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSPEED == 1)
                    // 100MBit speed
                    IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_100Mbps);
                else
                    // 1000MBit speed
                    IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_1000Mbps);
        }
    }
}
#endif

uint8 low_level_output(uint16 length)
{
    //IfxGeth_Eth      *ethernetif = netif->state;
    //struct pbuf *q;

    //u16_t        length = p->tot_len;
    //LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("low_level_output (p=%#x)\n", p));

    #if ETH_PAD_SIZE
        pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
    #endif

    //if ((p->type_internal == PBUF_REF) || (p->type_internal == PBUF_ROM))
    //{
        // if PBUF_REF or PBUF_ROM, no copy into ethernet RAM buffer is needed.
        // see pbuf_alloc_special()
        IfxGeth_Eth_sendTransmitBuffer(&ethernetif, length, IfxGeth_TxDmaChannel_0);
    //}
   // else
    //{
        //initiate transfer();
       // u8_t *tbuf = IfxGeth_Eth_waitTransmitBuffer(ethernetif, IfxGeth_TxDmaChannel_0);
        //u16_t l    = 0;

        //for (q = p; q != NULL; q = q->next)
        //{
            /* Send the data from the pbuf to the interface, one pbuf at a
             * time. The size of the data in each pbuf is kept in the ->len
             * variable. */
            //memcpy((u8_t *)&tbuf[l], q->payload, q->len);
            //l = l + q->len;
            //LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("low_level_output: data=%#x, %d\n", q->payload, q->len));
            //LWIP_ASSERT("low_level_output: length overflow the buffer\n", (l < 2048));
        //}
        /* we correct the buffer 1 size (maybe overwritten in earlier packet */
        //IfxGeth_TxDescr *pactTxDescriptor;
        //pactTxDescriptor = (IfxGeth_TxDescr *)IfxGeth_Eth_getActualTxDescriptor(ethernetif, IfxGeth_TxDmaChannel_0);
        /* set the buffer length to the max. available */
        //pactTxDescriptor->TDES2.R.B1L = IFXGETH_MAX_TX_BUFFER_SIZE;
        //IfxGeth_Eth_sendTransmitBuffer(ethernetif, l, IfxGeth_TxDmaChannel_0);
   // }

    //LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("low_level_output: signal length: %d\n", length));

    #if ETH_PAD_SIZE
        pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
    #endif

    //LINK_STATS_INC(link.xmit);

    //LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("low_level_output: return OK\n"));

   return 0;
}
