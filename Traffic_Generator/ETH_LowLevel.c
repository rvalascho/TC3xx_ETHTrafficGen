/**********************************************************************************************************************
 * \file ETH_LowLevel.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#define TOGGLE 1                                                /* Select  1 for DP83825i and 0 for RTL8211F        */

#include "IfxGeth.h"
#include "IfxGeth_Eth.h"
#include <string.h>

#if TOGGLE==1
#include "IfxGeth_Phy_Dp83825i.h"
#endif

#if TOGGLE==0
#include "IfxGeth_Phy_Rtl8211f.h"
#endif
#include "ETH_LowLevel.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/



#define CPU_WHICH_SERVICE_ETHERNET 0

#define ISR_PRIORITY_OS_TICK        99                          /* Define the timer interrupt priority              */
#define ISR_PRIORITY_GETH_TX        100                         /* Define the Ethernet transmit interrupt priority  */
#define ISR_PRIORITY_GETH_RX        101                         /* Define the Ethernet receive interrupt priority   */

#if TOGGLE==0
/* Pins for RTL8211F RMII connection */
#define ETH_GREFCLK_PIN             IfxGeth_GREFCLK_P11_5_IN
#define ETH_RXCTL_PIN               IfxGeth_RXCTLA_P11_11_IN
#define ETH_RXCLK_PIN               IfxGeth_RXCLKA_P11_12_IN
#define ETH_RXD0_PIN                IfxGeth_RXD0A_P11_10_IN
#define ETH_RXD1_PIN                IfxGeth_RXD1A_P11_9_IN
#define ETH_RXD2_PIN                IfxGeth_RXD2A_P11_8_IN
#define ETH_RXD3_PIN                IfxGeth_RXD3A_P11_7_IN
#define ETH_MDC_PIN                 IfxGeth_MDC_P21_2_OUT
#define ETH_MDIO_PIN                IfxGeth_MDIO_P21_3_INOUT
#define ETH_TXD0_PIN                IfxGeth_TXD0_P11_3_OUT
#define ETH_TXD1_PIN                IfxGeth_TXD1_P11_2_OUT
#define ETH_TXD2_PIN                IfxGeth_TXD2_P11_1_OUT
#define ETH_TXD3_PIN                IfxGeth_TXD3_P11_0_OUT
#define ETH_TXCTL_PIN               IfxGeth_TXCTL_P11_6_OUT
#define ETH_TXCLK_PIN               IfxGeth_TXCLK_P11_4_OUT
#endif

#if TOGGLE==1
/* Pins for DP83825U RMII connection */
#define ETH_CRSDIV_PIN              IfxGeth_CRSDVA_P11_11_IN
#define ETH_REFCLK_PIN              IfxGeth_REFCLKA_P11_12_IN
#define ETH_TXEN_PIN                IfxGeth_TXEN_P11_6_OUT
#define ETH_RXD0_PIN                IfxGeth_RXD0A_P11_10_IN
#define ETH_RXD1_PIN                IfxGeth_RXD1A_P11_9_IN
#define ETH_MDC_PIN                 IfxGeth_MDC_P21_2_OUT
#define ETH_MDIO_PIN                IfxGeth_MDIO_P21_3_INOUT
#define ETH_TXD0_PIN                IfxGeth_TXD0_P11_3_OUT
#define ETH_TXD1_PIN                IfxGeth_TXD1_P11_2_OUT
#endif
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGeth_Eth ethernetif;

#define NUM_TX_CHANNELS 8
#define NUM_RX_CHANNELS 1
uint8 channelTxBuffer1[NUM_TX_CHANNELS][IFXGETH_MAX_TX_DESCRIPTORS][IFXGETH_MAX_TX_BUFFER_SIZE];
uint8 channelRxBuffer1[NUM_RX_CHANNELS][IFXGETH_MAX_RX_DESCRIPTORS][IFXGETH_MAX_RX_BUFFER_SIZE];
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/* pin configuration RTL8211F */
#if TOGGLE == 0
const IfxGeth_Eth_RgmiiPins rgmii_pins = {
                                   .txClk = &ETH_TXCLK_PIN,     /* TXCLK */
                                   .txd0 = &ETH_TXD0_PIN,       /* TXD0 */
                                   .txd1 = &ETH_TXD1_PIN,       /* TXD1 */
                                   .txd2 = &ETH_TXD2_PIN,       /* TXD2 */
                                   .txd3 = &ETH_TXD3_PIN,       /* TXD3 */
                                   .txCtl = &ETH_TXCTL_PIN,     /* TXCTL */
                                   .rxClk = &ETH_RXCLK_PIN,     /* RXCLK */
                                   .rxd0 = &ETH_RXD0_PIN,       /* RXD0 */
                                   .rxd1 = &ETH_RXD1_PIN,       /* RXD1 */
                                   .rxd2 = &ETH_RXD2_PIN,       /* RXD2 */
                                   .rxd3 = &ETH_RXD3_PIN,       /* RXD3 */
                                   .rxCtl = &ETH_RXCTL_PIN,     /* RXCTL */
                                   .mdc = &ETH_MDC_PIN,         /* MDC */
                                   .mdio = &ETH_MDIO_PIN,       /* MDIO */
                                   .grefClk = &ETH_GREFCLK_PIN  /* GREFCLK */
};
#endif

#if TOGGLE==1
/* pin configuration DP83825I*/
const IfxGeth_Eth_RmiiPins rmii_pins = {
                                   .crsDiv = &ETH_CRSDIV_PIN,   /* CRSDIV */
                                   .refClk = &ETH_REFCLK_PIN,   /* REFCLK */
                                   .rxd0 = &ETH_RXD0_PIN,       /* RXD0 */
                                   .rxd1 = &ETH_RXD1_PIN,       /* RXD1 */
                                   .mdc = &ETH_MDC_PIN,         /* MDC */
                                   .mdio = &ETH_MDIO_PIN,       /* MDIO */
                                   .txd0 = &ETH_TXD0_PIN,       /* TXD0 */
                                   .txd1 = &ETH_TXD1_PIN,       /* TXD1 */
                                   .txEn = &ETH_TXEN_PIN        /* TXEN */
};
#endif

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

void ETH_configureQueues(IfxGeth_Eth_Config *config, uint8 numTx, uint8 numRx)
{
    config->mtl.numOfTxQueues = numTx;
    config->mtl.numOfRxQueues = numRx;
    config->dma.numOfTxChannels = numTx;
    config->dma.numOfRxChannels = numRx;

    for (uint8 i = 0; i < numTx; i++)
    {
        config->mtl.txQueue[i].txQueueSize     = IfxGeth_QueueSize_2560Bytes;
        config->mtl.txQueue[i].storeAndForward = TRUE;

        config->dma.txChannel[i].channelId       = (IfxGeth_TxDmaChannel)i;
        config->dma.txChannel[i].txDescrList     = (IfxGeth_TxDescrList *)&IfxGeth_Eth_txDescrList[i];
        config->dma.txChannel[i].txBuffer1StartAddress = (uint32 *)&channelTxBuffer1[i][0][0];
        config->dma.txChannel[i].txBuffer1Size   = IFXGETH_MAX_TX_BUFFER_SIZE;

        config->dma.txInterrupt[i].channelId = (IfxGeth_DmaChannel)i;
        config->dma.txInterrupt[i].priority  = ISR_PRIORITY_GETH_TX;
        config->dma.txInterrupt[i].provider  = (CPU_WHICH_SERVICE_ETHERNET ? (IfxSrc_Tos)(CPU_WHICH_SERVICE_ETHERNET + 1) : (IfxSrc_Tos)CPU_WHICH_SERVICE_ETHERNET);
    }

    for (uint8 i = 0; i < numRx; i++)
    {
        config->mtl.rxQueue[i].rxQueueSize       = IfxGeth_QueueSize_2560Bytes;
        config->mtl.rxQueue[i].storeAndForward   = TRUE;
        config->mtl.rxQueue[i].rxDmaChannelMap   = (IfxGeth_RxDmaChannel)i;

        config->dma.rxChannel[i].channelId       = (IfxGeth_RxDmaChannel)i;
        config->dma.rxChannel[i].rxDescrList     = (IfxGeth_RxDescrList *)&IfxGeth_Eth_rxDescrList[i];
        config->dma.rxChannel[i].rxBuffer1StartAddress = (uint32 *)&channelRxBuffer1[i][0][0];
        config->dma.rxChannel[i].rxBuffer1Size   = IFXGETH_MAX_RX_BUFFER_SIZE;

        config->dma.rxInterrupt[i].channelId = (IfxGeth_DmaChannel)i;
        config->dma.rxInterrupt[i].priority  = ISR_PRIORITY_GETH_RX;
        config->dma.rxInterrupt[i].provider  = (CPU_WHICH_SERVICE_ETHERNET ? (IfxSrc_Tos)(CPU_WHICH_SERVICE_ETHERNET + 1) : (IfxSrc_Tos)CPU_WHICH_SERVICE_ETHERNET);
    }

}

#if TOGGLE==1
void ETH_lowlevel_init_RMII(uint8 numTxQueues, uint8 numRxQueues)
{

    {
        IfxGeth_Eth_Config GethConfig;

        IfxGeth_Eth_initModuleConfig(&GethConfig, &MODULE_GETH);
        // this is our RTL8211F
        GethConfig.phyInterfaceMode = IfxGeth_PhyInterfaceMode_rmii;
        GethConfig.pins.rmiiPins = &rmii_pins;
        GethConfig.mac.lineSpeed = IfxGeth_LineSpeed_100Mbps; //IfxGeth_LineSpeed_1000Mbps;
        // MAC core configuration
        GethConfig.mac.loopbackMode = IfxGeth_LoopbackMode_disable;
        GethConfig.mac.macAddress[0] = 0x66;
        GethConfig.mac.macAddress[1] = 0x55;
        GethConfig.mac.macAddress[2] = 0x44;
        GethConfig.mac.macAddress[3] = 0x33;
        GethConfig.mac.macAddress[4] = 0x22;
        GethConfig.mac.macAddress[5] = 0x11;

        GethConfig.mtl.txSchedulingAlgorithm = IfxGeth_TxSchedulingAlgorithm_sp;
        ETH_configureQueues(&GethConfig, numTxQueues, numRxQueues);
        // initialize the module
        IfxGeth_enableModule(&MODULE_GETH);

        IfxPort_setPinModeOutput(ETH_MDC_PIN.pin.port, ETH_MDC_PIN.pin.pinIndex, IfxPort_OutputMode_pushPull, ETH_MDC_PIN.select);
            GETH_GPCTL.B.ALTI0  = ETH_MDIO_PIN.inSelect;
        IfxGeth_Eth_initModule(&ethernetif, &GethConfig);

        IfxGeth_Eth_Phy_Dp83825i_init();

        // and enable transmitter/receiver
        IfxGeth_Eth_startTransmitters(&ethernetif, numTxQueues);
        IfxGeth_Eth_startReceivers(&ethernetif, numRxQueues);

        // The ETH is ready for use now!
        /* we set the LINK_UP flag if we have a valid link */
        if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSTS == 1)
        {
            // we have a valid link
            // we set the correct duplexMode
            if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKMOD == 1)
                IfxGeth_mac_setDuplexMode(ethernetif.gethSFR, IfxGeth_DuplexMode_fullDuplex);
            else
                IfxGeth_mac_setDuplexMode(ethernetif.gethSFR, IfxGeth_DuplexMode_halfDuplex);
            // we set the correct speed
            if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSPEED == 0)
                // 10MBit speed
                IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_10Mbps);
            else
                if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSPEED == 1)
                    // 100MBit speed
                    IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_100Mbps);
                else
                    // 1000MBit speed
                    IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_1000Mbps);
        }
    }
}
#endif

#if TOGGLE==0
void ETH_lowlevel_init_RGMII(uint8 numTxQueues, uint8 numRxQueues)
{
    {
        IfxGeth_Eth_Config GethConfig;

        IfxGeth_Eth_initModuleConfig(&GethConfig, &MODULE_GETH);
        // this is our RTL8211F
        GethConfig.phyInterfaceMode = IfxGeth_PhyInterfaceMode_rgmii;
        GethConfig.pins.rgmiiPins = &rgmii_pins;
        GethConfig.mac.lineSpeed = IfxGeth_LineSpeed_100Mbps;
        // MAC core configuration
        GethConfig.mac.loopbackMode = IfxGeth_LoopbackMode_disable;
        GethConfig.mac.macAddress[0] = 0xDE;
        GethConfig.mac.macAddress[1] = 0xAD;
        GethConfig.mac.macAddress[2] = 0xBE;
        GethConfig.mac.macAddress[3] = 0xEF;
        GethConfig.mac.macAddress[4] = 0xDE;
        GethConfig.mac.macAddress[5] = 0xAD;

        GethConfig.mtl.txSchedulingAlgorithm = IfxGeth_TxSchedulingAlgorithm_sp;
        ETH_configureQueues(&GethConfig, numTxQueues, numRxQueues);

        /* first we reset our phy manually, to make sure that the phy is ready when we init our module */
        {
            IfxGeth_enableModule(&MODULE_GETH);
            IfxPort_setPinModeOutput(ETH_MDC_PIN.pin.port, ETH_MDC_PIN.pin.pinIndex, IfxPort_OutputMode_pushPull, ETH_MDC_PIN.select);
            GETH_GPCTL.B.ALTI0  = ETH_MDIO_PIN.inSelect;

            while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
            // first we wait that we are able to communicate with the Phy
            do
            {
                GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) | (3 << 2) | (1 << 0);
                while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
            } while (GETH_MAC_MDIO_DATA.U & 0x8000);                                                      // wait for reset to finish
            // reset PHY
            // put data
            GETH_MAC_MDIO_DATA.U = 0x8000;
            GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) |  (1 << 2) | (1 << 0);
            while (GETH_MAC_MDIO_ADDRESS.B.GB) {};

            do
            {
                GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) | (3 << 2) | (1 << 0);
                while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
            } while (GETH_MAC_MDIO_DATA.U & 0x8000);                                                      // wait for reset to finish
        }

        // initialize the module
        IfxGeth_Eth_initModule(&ethernetif, &GethConfig);

        IfxGeth_Eth_Phy_Rtl8211f_init();

        // and enable transmitter/receiver
        IfxGeth_Eth_startTransmitters(&ethernetif, numTxQueues);
        IfxGeth_Eth_startReceivers(&ethernetif, numRxQueues);

        // The ETH is ready for use now!
        /* we set the LINK_UP flag if we have a valid link */
        if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSTS == 1)
        {
            // we set the correct duplexMode
            if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKMOD == 1)
                IfxGeth_mac_setDuplexMode(ethernetif.gethSFR, IfxGeth_DuplexMode_fullDuplex);
            else
                IfxGeth_mac_setDuplexMode(ethernetif.gethSFR, IfxGeth_DuplexMode_halfDuplex);
            // we set the correct speed
            if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSPEED == 0)
                // 10MBit speed
                IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_10Mbps);
            else
                if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSPEED == 1)
                    // 100MBit speed
                    IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_100Mbps);
                else
                    // 1000MBit speed
                    IfxGeth_mac_setLineSpeed(ethernetif.gethSFR, IfxGeth_LineSpeed_1000Mbps);
        }
    }
}
#endif

uint8 low_level_output(uint8 **payloads, uint16 *lengths, uint8 count)
{
    for (uint8 i = 0; i < count; i++)
    {
        IfxGeth_TxDmaChannel dmaChannel = (IfxGeth_TxDmaChannel)(i % count);

        uint8 *txBuf = IfxGeth_Eth_waitTransmitBuffer(&ethernetif, dmaChannel);
        memcpy(txBuf, payloads[i], lengths[i]);
        IfxGeth_Eth_sendTransmitBuffer(&ethernetif, lengths[i], dmaChannel);
    }
    return 0;
}
